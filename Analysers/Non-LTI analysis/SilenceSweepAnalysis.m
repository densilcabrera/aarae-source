function OUT = SilenceSweepAnalysis(IN,octsmooth)

if ~isfield(IN,'properties')
    if nargin == 1
        warndlg('Required properties field is missing from the input audio. This analyser is designed to analyse recorded signals using the test signal generated by SilenceSweep_Farina2009. Unable to analyse.','SilenceSweepAnalysis','modal');
    end
    OUT = [];
    return
end

if ~isfield(IN.properties,'SilenceSweep')
    if nargin == 1
        warndlg('Required properties field is missing from the input audio. This analyser is designed to analyse recorded signals using the test signal generated by SilenceSweep_Farina2009. Unable to analyse.','SilenceSweepAnalysis','modal');
    end
    OUT = [];
    return
end

octsmooth = 0;
DCCoupling = 0;
MLSlen = 2^IN.properties.MLSorder-1;
sweeplen = round(IN.properties.sweepdur * IN.fs);
gaplen = round(IN.properties.gapdur * IN.fs);
winlen = round(MLSlen/2);
wf = hann(winlen);
NOVERLAP = ceil(winlen/3);
fs = IN.fs;

[~,chans,bands,dim4,dim5,dim6] = size(IN.audio);

if bands > 1
    % sum multiple bands
    audio = sum(audio,3);
end


if dim4 > 1 % multicycle
    % this should not occur, unless the user has convolved with audio2
    % prior to calling this function
    if isfield(IN.properties,'relgain')
        if isinf(IN.properties.relgain(1))
            % discard silent cycle (it is redundant because the test signal
            % includes silence) & apply synchronous average
            audio = mean(audio(:,:,1,2:end,:,:),4);
        end
    else
        % synchronous average
        audio = mean(audio,4);
    end
end


linecolor = HSVplotcolours2(chans, 5, dim5); % H,S,V
% ANALYSE SNR, USING UNCONVOLVED RECORDING
if isfield(IN,'audio2') % this indicates that convolution has not been done
    noise = IN.audio(1:sweeplen,:,:,:,:,:); % should be safe unless there is negative latency
    signal = IN.audio(sweeplen+gaplen+2*MLSlen:sweeplen+gaplen+8*MLSlen+1,:,:,:,:,:); % allowing for latency issues
    [SigPow, NoisePow,SNR] = deal(zeros(floor(winlen/2),chans,dim5,dim6));
    for ch = 1:chans
        for d5 = 1:dim5
            for d6 = 1:dim6
                [~,f,~,P1] = spectrogram(noise(:,ch,1,1,d5,d6),wf,NOVERLAP,[],fs);
                [~,~,~,P2] = spectrogram(signal(:,ch,1,1,d5,d6),wf,NOVERLAP,[],fs);
                NoisePow(:,ch,d5,d6) = mean(P1(1:floor(winlen/2),:),2);
                SigPow(:,ch,d5,d6) = mean(P2(1:floor(winlen/2),:),2);
                SNR(:,ch,d5,d6) = SigPow(:,ch,d5,d6)./NoisePow(:,ch,d5,d6); % although this looks inefficient, it is done here to avoid smoothing artefacts
                if octsmooth > 0
                    NoisePow(:,ch,d5,d6) = octavesmoothing(NoisePow(:,ch,d5,d6),octsmooth, fs);
                    SigPow(:,ch,d5,d6) = octavesmoothing(SigPow(:,ch,d5,d6),octsmooth, fs);
                    SNR(:,ch,d5,d6) = octavesmoothing(SNR(:,ch,d5,d6),octsmooth, fs);
                end
            end
        end
    end
    clear signal noise P1 P2
    f=f(1:floor(winlen/2));
    if octsmooth > 0
        lowlimit = 128/(winlen/fs); % avoid very low freq hump error
        NoisePow = NoisePow(f>lowlimit,:,:,:,:,:);
        NoisePow(NoisePow<0)=0;
        SigPow = SigPow(f>lowlimit,:,:,:,:,:);
        SigPow(SigPow<0)=0;
        SNR = SNR(f>lowlimit,:,:,:,:,:);
        SNR(SNR<0)=0;
        f = f(f>lowlimit);
    end
    
    
    % Generate figure(s) for SNR analysis
    for d6 = 1:dim6
        figure('Name','Signal, Noise, and SNR');
        for ch = 1:chans
            for d5 = 1:dim5
                labelstring = 'hello';
                
                subplot(2,1,1) % plot of Signal and Noise spectra
                colr = permute(linecolor(ch,1,d5,:),[1,4,2,3]);
                semilogx(f,10*log10(NoisePow(:,ch,d5,d6)),...
                    'color',colr,...
                    'DisplayName',labelstring);
                hold on
                colr = permute(linecolor(ch,3,d5,:),[1,4,2,3]);
                semilogx(f,10*log10(SigPow(:,ch,d5,d6)),...
                    'color',colr,...
                    'DisplayName',labelstring);
                
                
                colr = permute(linecolor(ch,2,d5,:),[1,4,2,3]);
                subplot(2,1,2) % plot of SNR
                semilogx(f,10*log10(SNR(:,ch,d5,d6)),...
                    'color',colr,...
                    'DisplayName',labelstring);
                hold on
            end
        end
        subplot(2,1,1)
        title('Signal and Noise')
        xlabel('Frequency [Hz]')
        ylabel('Level [dB]')
        xlim([20,20000])
        
        subplot(2,1,2)
        title('Signal-to-Noise Ratio')
        xlabel('Frequency [Hz]')
        ylabel('Level [dB]')
        xlim([20,20000])
    end
end




% CONVOLVE AUDIO WITH INVERSE SWEEP (IN.audio2)
if isfield(IN,'audio2')
    IN = convolveaudiowithaudio2(IN,1,0,1);
else
    % We assume that convolution with audio2 has already been done.
    % Check that minimum length requirement is met
    if size(IN.audio,1) < floor(41*(2^IN.properties.MLSorder-1) ...
            + IN.fs*(2*IN.properties.gapdur + IN.properties.sweepdur) - 1)
        warndlg('Input audio is too short to analyse automatically. It looks like it has been truncated. Try inputting the recording (instead of the ''*'' convolved recording).','SilenceSweepAnalysis','modal');
        OUT = [];
        return
    end
end





% TIME ALIGN AUDIO WITH THE GAP BETWEEN MLS (USING CROSS-CORRELATION PEAK INDEX)
MLSgapmodel = [ones(MLSlen,1);...
    zeros(MLSlen,1);
    ones(2*MLSlen,1)];
MLSgapstart = sweeplen + gaplen + 20*MLSlen + 1;
x = ifftshift(ifft(conj(fft(...
    IN.audio(MLSgapstart-MLSlen-1:MLSgapstart+3*MLSlen-2,1,1,1,1,1).^2))...
    .* fft(MLSgapmodel)));
[~,mx]=max(x);
K = mx-round(length(x)/2)-1;
IN.audio = circshift(IN.audio,K);
clear x MLSgapmodel

% ANALYSE MLS AS NOISE, and GAP
MLSnoise1 = IN.audio(sweeplen+gaplen+11*MLSlen+1:sweeplen+gaplen+19*MLSlen,:,:,:,:,:);
MLSnoise2 = IN.audio(sweeplen+gaplen+22*MLSlen+1:sweeplen+gaplen+29*MLSlen,:,:,:,:,:);
gapmargin = round(MLSlen*0.05);
MLSgap = IN.audio(MLSgapstart+gapmargin:MLSgapstart+MLSlen-gapmargin,:,:,:,:,:);
NoisebeforeMLS = IN.audio(sweeplen+1+gapmargin:sweeplen+gaplen-gapmargin,:,:,:,:,:);
[SigPow2, NoiseDistPow,NoisebeforeMLSPow,SNR2,SINAD] = deal(zeros(floor(winlen/2),chans,dim5,dim6));
for ch = 1:chans
    for d5 = 1:dim5
        for d6 = 1:dim6
            [~,f,~,P1] = spectrogram(MLSnoise1(:,ch,1,1,d5,d6),wf,NOVERLAP,[],fs);
            [~,~,~,P2] = spectrogram(MLSnoise2(:,ch,1,1,d5,d6),wf,NOVERLAP,[],fs);
            [~,~,~,P3] = spectrogram(MLSgap(:,ch,1,1,d5,d6),wf,NOVERLAP,[],fs);
            [~,~,~,P4] = spectrogram(NoisebeforeMLS(:,ch,1,1,d5,d6),wf,NOVERLAP,[],fs);
            NoiseDistPow(:,ch,d5,d6) = mean(P3(1:floor(winlen/2),:),2);
            NoisebeforeMLSPow(:,ch,d5,d6) = mean(P4(1:floor(winlen/2),:),2);
            SigPow2(:,ch,d5,d6) = mean([P1(1:floor(winlen/2),:),...
                P2(1:floor(winlen/2),:)],2);
            SNR2(:,ch,d5,d6) = SigPow2(:,ch,d5,d6)./NoisebeforeMLSPow(:,ch,d5,d6); % although this looks inefficient, it is done here to avoid smoothing artefacts
            SINAD(:,ch,d5,d6) = SigPow2(:,ch,d5,d6)./NoiseDistPow(:,ch,d5,d6);
            if octsmooth > 0
                NoisebeforeMLSPow(:,ch,d5,d6) = octavesmoothing(NoisebeforeMLSPow(:,ch,d5,d6),octsmooth, fs);
                NoiseDistPow(:,ch,d5,d6) = octavesmoothing(NoiseDistPow(:,ch,d5,d6),octsmooth, fs);
                SigPow2(:,ch,d5,d6) = octavesmoothing(SigPow2(:,ch,d5,d6),octsmooth, fs);
                SNR2(:,ch,d5,d6) = octavesmoothing(SNR2(:,ch,d5,d6),octsmooth, fs);
                SINAD(:,ch,d5,d6) = octavesmoothing(SINAD(:,ch,d5,d6),octsmooth, fs);
            end
        end
    end
end
clear MLSgap NoisebeforeMLS P1 P2 P3 P4
f=f(1:floor(winlen/2));
if octsmooth > 0
    lowlimit = 128/(winlen/fs); % avoid very low freq hump error
    NoisebeforeMLSPow = NoisebeforeMLSPow(f>lowlimit,:,:,:,:,:);
    NoisebeforeMLSPow(NoisebeforeMLSPow<0)=0;
    NoiseDistPow = NoiseDistPow(f>lowlimit,:,:,:,:,:);
    NoiseDistPow(NoiseDistPow<0)=0;
    SigPow2 = SigPow2(f>lowlimit,:,:,:,:,:);
    SigPow2(SigPow2<0)=0;
    SNR2 = SNR2(f>lowlimit,:,:,:,:,:);
    SNR2(SNR2<0)=0;
    SINAD = SINAD(f>lowlimit,:,:,:,:,:);
    SINAD(SINAD<0)=0;
    f = f(f>lowlimit);
end


% Generate figure(s) for SNR analysis
for d6 = 1:dim6
    figure('Name','Signal, Noise, and SNR');
    for ch = 1:chans
        for d5 = 1:dim5
            labelstring = 'hello';
            
            subplot(2,1,1) % plot of Signal and Noise spectra
            colr = permute(linecolor(ch,1,d5,:),[1,4,2,3]);
            semilogx(f,10*log10(NoisebeforeMLSPow(:,ch,d5,d6)),...
                'color',colr,...
                'DisplayName',labelstring);
            hold on
            
            colr = permute(linecolor(ch,2,d5,:),[1,4,2,3]);
            semilogx(f,10*log10(NoiseDistPow(:,ch,d5,d6)),...
                'color',colr,...
                'DisplayName',labelstring);
            
            colr = permute(linecolor(ch,3,d5,:),[1,4,2,3]);
            semilogx(f,10*log10(SigPow2(:,ch,d5,d6)),...
                'color',colr,...
                'DisplayName',labelstring);
            
            
            colr = permute(linecolor(ch,2,d5,:),[1,4,2,3]);
            subplot(2,1,2) % plot of SNR
            semilogx(f,10*log10(SNR2(:,ch,d5,d6)),...
                'color',colr,...
                'DisplayName',labelstring);
            hold on
            colr = permute(linecolor(ch,4,d5,:),[1,4,2,3]);
            semilogx(f,10*log10(SINAD(:,ch,d5,d6)),...
                'color',colr,...
                'DisplayName',labelstring);
        end
    end
    subplot(2,1,1)
    title('Signal, Noise and Distorion+Noise')
    xlabel('Frequency [Hz]')
    ylabel('Level [dB]')
    xlim([20,20000])
    
    subplot(2,1,2)
    title('SNR and SINAD')
    xlabel('Frequency [Hz]')
    ylabel('Level [dB]')
    xlim([20,20000])
end


% ANALYSE IR FROM MLS
[ir1,ir2] = deal(zeros(2^IN.properties.MLSorder,chans,dim5,dim6));
impalign = 0;
for d5 = 1:dim5
    for d6 = 1:dim6
        ir1(:,:,d5,d6) = AnalyseMLSSequence(MLSnoise1(:,:,1,1,d5,d6),...
            0,8,IN.properties.MLSorder,DCCoupling,impalign);
        ir2(:,:,d6,d6) = AnalyseMLSSequence(MLSnoise2(:,:,1,1,d5,d6),...
            0,7,IN.properties.MLSorder,DCCoupling,impalign);
    end
end
MLSir = (8*ir1+7*ir2)./15;
clear ir1 ir2
%preshift = round(MLSlen*0.025);
MLSir = circshift(MLSir,round(winlen/2));
MLSir = MLSir(1:winlen,:,:,:,:,:);
MLSspect = 10*log10(fft(MLSir.*repmat(wf,[1,chans,1,1,dim5,dim6])).^2);

% ANALYSE IR FROM SWEEP, INCLUDING HARMONIC DISTORTION
IRstartindex = sweeplen+gaplen+32*MLSlen+gaplen+sweeplen-round(winlen/2)+1;
harmonicoffsets=round((log10(1:5))./...
    (1./sweeplen...
    .*log10(IN.properties.end_freq./IN.properties.start_freq))); % harmonics 1:5 are separated by more than MLSlen.
diffharmonicoffsets=diff(harmonicoffsets);
sweepIR1 = IN.audio(IRstartindex:IRstartindex+winlen-1,:,:,:,:,:);
sweepIR2 = IN.audio(IRstartindex-harmonicoffsets(2):IRstartindex-harmonicoffsets(2)+winlen-1,:,:,:,:,:);
sweepIR3 = IN.audio(IRstartindex-harmonicoffsets(3):IRstartindex-harmonicoffsets(3)+winlen-1,:,:,:,:,:);
sweepIR4 = IN.audio(IRstartindex-harmonicoffsets(4):IRstartindex-harmonicoffsets(4)+winlen-1,:,:,:,:,:);
sweepIR5 = IN.audio(IRstartindex-harmonicoffsets(5):IRstartindex-harmonicoffsets(5)+winlen-1,:,:,:,:,:);
sweepspect1 = 10*log10(fft(sweepIR1.*repmat(wf,[1,chans,1,1,dim5,dim6])).^2);
sweepspect2 = 10*log10(fft(sweepIR2.*repmat(wf,[1,chans,1,1,dim5,dim6])).^2);
sweepspect3 = 10*log10(fft(sweepIR3.*repmat(wf,[1,chans,1,1,dim5,dim6])).^2);
sweepspect4 = 10*log10(fft(sweepIR4.*repmat(wf,[1,chans,1,1,dim5,dim6])).^2);
sweepspect5 = 10*log10(fft(sweepIR5.*repmat(wf,[1,chans,1,1,dim5,dim6])).^2);

% ANALYSE INVERSE-FILTERED SILENCE AT THE START TO ESTIMATE EFFECTIVE
% BACKGROUND NOISE USING EQUIVALENT TIME PERIODS TO THOSE OF THE SWEEP
IRstartindex = sweeplen-round(winlen/2)+1;
silenceIR1 = IN.audio(IRstartindex:IRstartindex+winlen-1,:,:,:,:,:);
silenceIR2 = IN.audio(IRstartindex-harmonicoffsets(2):IRstartindex-harmonicoffsets(2)+winlen-1,:,:,:,:,:);
silenceIR3 = IN.audio(IRstartindex-harmonicoffsets(3):IRstartindex-harmonicoffsets(3)+winlen-1,:,:,:,:,:);
silenceIR4 = IN.audio(IRstartindex-harmonicoffsets(4):IRstartindex-harmonicoffsets(4)+winlen-1,:,:,:,:,:);
silenceIR5 = IN.audio(IRstartindex-harmonicoffsets(5):IRstartindex-harmonicoffsets(5)+winlen-1,:,:,:,:,:);
silencespect1 = 10*log10(fft(silenceIR1.*repmat(wf,[1,chans,1,1,dim5,dim6])).^2);
silencespect2 = 10*log10(fft(silenceIR2.*repmat(wf,[1,chans,1,1,dim5,dim6])).^2);
silencespect3 = 10*log10(fft(silenceIR3.*repmat(wf,[1,chans,1,1,dim5,dim6])).^2);
silencespect4 = 10*log10(fft(silenceIR4.*repmat(wf,[1,chans,1,1,dim5,dim6])).^2);
silencespect5 = 10*log10(fft(silenceIR5.*repmat(wf,[1,chans,1,1,dim5,dim6])).^2);



t = (0:winlen-1)'./fs;
f = fs*(0:round(winlen/2))'./winlen;
for d6 = 1:dim6
    compplot=figure('Name','SilenceSweep IR analysis');
    for d5 = 1:dim5
        for ch = 1:chans
            subplot(3,2,1)
            colr = permute(linecolor(ch,1,d5,:),[1,4,2,3]);
            plot(t,10*log10(MLSir(:,ch,1,1,d5,d6).^2),...
                'color',colr,...
                'DisplayName',labelstring);
            
            subplot(3,2,2)
            colr = permute(linecolor(ch,1,d5,:),[1,4,2,3]);
            plot(t,10*log10(sweepIR1(:,ch,1,1,d5,d6).^2),...
                'color',colr,...
                'DisplayName',labelstring);
            
            subplot(3,2,3)
            colr = permute(linecolor(ch,1,d5,:),[1,4,2,3]);
            plot(t,10*log10(sweepIR2(:,ch,1,1,d5,d6).^2),...
                'color',colr,...
                'DisplayName',labelstring);
            
            subplot(3,2,4)
            colr = permute(linecolor(ch,1,d5,:),[1,4,2,3]);
            plot(t,10*log10(sweepIR3(:,ch,1,1,d5,d6).^2),...
                'color',colr,...
                'DisplayName',labelstring);
            
            subplot(3,2,5)
            colr = permute(linecolor(ch,1,d5,:),[1,4,2,3]);
            plot(t,10*log10(sweepIR4(:,ch,1,1,d5,d6).^2),...
                'color',colr,...
                'DisplayName',labelstring);
            
            subplot(3,2,6)
            colr = permute(linecolor(ch,1,d5,:),[1,4,2,3]);
            plot(t,10*log10(sweepIR5(:,ch,1,1,d5,d6).^2),...
                'color',colr,...
                'DisplayName',labelstring);
            
            
        end
    end
    iplots = get(compplot,'Children');
    if length(iplots) > 1
        xlims = cell2mat(get(iplots,'Xlim'));
        set(iplots,'Xlim',[min(xlims(:,1)) max(xlims(:,2))])
        ylims = cell2mat(get(iplots,'Ylim'));
        set(iplots,'Ylim',[min(ylims(:,1)) max(ylims(:,2))])
        uicontrol('Style', 'pushbutton', 'String', 'Axes limits',...
            'Position', [0 0 65 30],...
            'Callback', 'setaxeslimits');
    end
end

for d6 = 1:dim6
    compplot=figure('Name','SilenceSweep IR spectrum analysis');
    for d5 = 1:dim5
        for ch = 1:chans
            
            subplot(3,2,1)
            colr = permute(linecolor(ch,1,d5,:),[1,4,2,3]);
            semilogx(f,MLSspect(1:length(f),ch,1,1,d5,d6),...
                'color',colr,...
                'DisplayName',labelstring);
            
            subplot(3,2,2)
            colr = permute(linecolor(ch,1,d5,:),[1,4,2,3]);
            semilogx(f,sweepspect1(1:length(f),ch,1,1,d5,d6),...
                'color',colr,...
                'DisplayName',labelstring);
            
            subplot(3,2,3)
            colr = permute(linecolor(ch,1,d5,:),[1,4,2,3]);
            semilogx(f,sweepspect2(1:length(f),ch,1,1,d5,d6),...
                'color',colr,...
                'DisplayName',labelstring);
            
            subplot(3,2,4)
            colr = permute(linecolor(ch,1,d5,:),[1,4,2,3]);
            semilogx(f,sweepspect3(1:length(f),ch,1,1,d5,d6),...
                'color',colr,...
                'DisplayName',labelstring);
            
            subplot(3,2,5)
            colr = permute(linecolor(ch,1,d5,:),[1,4,2,3]);
            semilogx(f,sweepspect4(1:length(f),ch,1,1,d5,d6),...
                'color',colr,...
                'DisplayName',labelstring);
            
            subplot(3,2,6)
            colr = permute(linecolor(ch,1,d5,:),[1,4,2,3]);
            semilogx(f,sweepspect5(1:length(f),ch,1,1,d5,d6),...
                'color',colr,...
                'DisplayName',labelstring);
            
        end
    end
    iplots = get(compplot,'Children');
    if length(iplots) > 1
        xlims = cell2mat(get(iplots,'Xlim'));
        set(iplots,'Xlim',[min(xlims(:,1)) max(xlims(:,2))])
        ylims = cell2mat(get(iplots,'Ylim'));
        set(iplots,'Ylim',[min(ylims(:,1)) max(ylims(:,2))])
        uicontrol('Style', 'pushbutton', 'String', 'Axes limits',...
            'Position', [0 0 65 30],...
            'Callback', 'setaxeslimits');
    end
end

% plot MLSir and sweepIRs in time & frequency domains (dB)


OUT.funcallback.name = 'SilenceSweepAnalysis.m';
OUT.funcallback.inarg = {octsmooth};


%**************************************************************************
% Copyright (c) 2015, Densil Cabrera
% All rights reserved.
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are
% met:
%
%  * Redistributions of source code must retain the above copyright notice,
%    this list of conditions and the following disclaimer.
%  * Redistributions in binary form must reproduce the above copyright
%    notice, this list of conditions and the following disclaimer in the
%    documentation and/or other materials provided with the distribution.
%  * Neither the name of the The University of Sydney nor the names of its contributors
%    may be used to endorse or promote products derived from this software
%    without specific prior written permission.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
% "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
% TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
% PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
% OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
% EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
% PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
% PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
% LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
% NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
% SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%**************************************************************************