function OUT = SilenceSweepAnalysis(IN)

if ~isfield(IN,'properties')
    warndlg('Required properties field is missing from the input audio. This analyser is designed to analyse recorded signals using the test signal generated by SilenceSweep_Farina2009. Unable to analyse.','SilenceSweepAnalysis','modal');
    OUT = [];
    return
end

if ~isfield(IN.properties,'SilenceSweep')
    warndlg('Required properties field is missing from the input audio. This analyser is designed to analyse recorded signals using the test signal generated by SilenceSweep_Farina2009. Unable to analyse.','SilenceSweepAnalysis','modal');
    OUT = [];
    return
end

octsmooth = 0;
MLSlen = 2^IN.properties.MLSorder-1;
sweeplen = round(IN.properties.sweepdur * IN.fs);
gaplen = round(IN.properties.gapdur * IN.fs);
winlen = round(MLSlen/2);
wf = hann(winlen);
NOVERLAP = ceil(winlen/3);
fs = IN.fs;

[~,chans,bands,dim4,dim5,dim6] = size(IN.audio);

if bands > 1
    % sum multiple bands
    audio = sum(audio,3);
end


if dim4 > 1 % multicycle
    % this should not occur, unless the user has convolved with audio2
    % prior to calling this function
    if isfield(IN.properties,'relgain')
        if isinf(IN.properties.relgain(1))
            % discard silent cycle (it is redundant because the test signal
            % includes silence) & apply synchronous average
            audio = mean(audio(:,:,1,2:end,:,:),4);
        end
    else
        % synchronous average
        audio = mean(audio,4);
    end
end


linecolor = HSVplotcolours2(chans, 5, dim5); % H,S,V
% ANALYSE SNR, USING UNCONVOLVED RECORDING
if isfield(IN,'audio2') % this indicates that convolution has not been done
    noise = IN.audio(1:sweeplen,:,:,:,:,:); % should be safe unless there is negative latency
    signal = IN.audio(sweeplen+gaplen+2*MLSlen:sweeplen+gaplen+8*MLSlen+1,:,:,:,:,:); % allowing for latency issues
    [SigPow, NoisePow,SNR] = deal(zeros(floor(winlen/2),chans,dim5,dim6));    
    for ch = 1:chans
        for d5 = 1:dim5
            for d6 = 1:dim6
                [~,f,~,P1] = spectrogram(noise(:,ch,1,1,d5,d6),wf,NOVERLAP,[],fs);
                [~,~,~,P2] = spectrogram(signal(:,ch,1,1,d5,d6),wf,NOVERLAP,[],fs);
                NoisePow(:,ch,d5,d6) = mean(P1(1:floor(winlen/2),:),2);
                SigPow(:,ch,d5,d6) = mean(P2(1:floor(winlen/2),:),2);
                SNR(:,ch,d5,d6) = SigPow(:,ch,d5,d6)./NoisePow(:,ch,d5,d6); % although this looks inefficient, it is done here to avoid smoothing artefacts
                if octsmooth > 0
                    NoisePow(:,ch,d5,d6) = octavesmoothing(NoisePow(:,ch,d5,d6),octsmooth, fs);
                    SigPow(:,ch,d5,d6) = octavesmoothing(SigPow(:,ch,d5,d6),octsmooth, fs);
                    SNR(:,ch,d5,d6) = octavesmoothing(SNR(:,ch,d5,d6),octsmooth, fs);
                end
            end
        end
    end
    clear signal noise P1 P2
    f=f(1:floor(winlen/2));
    if octsmooth > 0
        lowlimit = 128/(winlen/fs); % avoid very low freq hump error
        NoisePow = NoisePow(f>lowlimit,:,:,:,:,:);
        NoisePow(NoisePow<0)=0;
        SigPow = SigPow(f>lowlimit,:,:,:,:,:);
        SigPow(SigPow<0)=0;
        SNR = SNR(f>lowlimit,:,:,:,:,:);
        SNR(SNR<0)=0;
        f = f(f>lowlimit);
    end

    
    % Generate figure(s) for SNR analysis
    for d6 = 1:dim6
        figure('Name','Signal, Noise, and SNR');
        for ch = 1:chans
            for d5 = 1:dim5
                labelstring = 'hello';
                
                subplot(2,1,1) % plot of Signal and Noise spectra
                colr = permute(linecolor(ch,1,d5,:),[1,4,2,3]);
                semilogx(f,10*log10(NoisePow(:,ch,d5,d6)),...
                    'color',colr,...
                    'DisplayName',labelstring);
                hold on
                colr = permute(linecolor(ch,3,d5,:),[1,4,2,3]);
                semilogx(f,10*log10(SigPow(:,ch,d5,d6)),...
                    'color',colr,...
                    'DisplayName',labelstring);
                
                  
                colr = permute(linecolor(ch,2,d5,:),[1,4,2,3]);
                subplot(2,1,2) % plot of SNR
                semilogx(f,10*log10(SNR(:,ch,d5,d6)),...
                    'color',colr,...
                    'DisplayName',labelstring);
                hold on
            end
        end
        subplot(2,1,1)
        title('Signal and Noise')
        xlabel('Frequency [Hz]')
                ylabel('Level [dB]')
                xlim([20,20000])
        
        subplot(2,1,2)
        title('Signal-to-Noise Ratio')
        xlabel('Frequency [Hz]')
                ylabel('Level [dB]')
                xlim([20,20000])
    end
end




% CONVOLVE AUDIO WITH INVERSE SWEEP (IN.audio2)
if isfield(IN,'audio2')
    IN = convolveaudiowithaudio2(IN,1,0,1);
else
    % We assume that convolution with audio2 has already been done.
    % Check that minimum length requirement is met
    if size(IN.audio,1) < floor(41*(2^IN.properties.MLSorder-1) ...
            + IN.fs*(2*IN.properties.gapdur + IN.properties.sweepdur) - 1)
        warndlg('Input audio is too short to analyse automatically. It looks like it has been truncated. Try inputting the recording (instead of the ''*'' convolved recording).','SilenceSweepAnalysis','modal');
        OUT = [];
        return
    end
end





% TIME ALIGN AUDIO WITH THE GAP BETWEEN MLS (USING CROSS-CORRELATION PEAK INDEX)
MLSgapmodel = [ones(MLSlen,1);...
    zeros(MLSlen,1);
    ones(2*MLSlen,1)];
MLSgapstart = sweeplen + gaplen + 20*MLSlen + 1;
x = ifftshift(ifft(conj(fft(...
    IN.audio(MLSgapstart-MLSlen-1:MLSgapstart+3*MLSlen-2,1,1,1,1,1).^2))...
    .* fft(MLSgapmodel)));
[~,mx]=max(x);
K = mx-round(length(x)/2)-1;
IN.audio = circshift(IN.audio,K);
clear x MLSgapmodel

% ANALYSE MLS AS NOISE, and GAP
MLSnoise1 = IN.audio(sweeplen+gaplen+11*MLSlen+1:sweeplen+gaplen+19*MLSlen,:,:,:,:,:);
MLSnoise2 = IN.audio(sweeplen+gaplen+22*MLSlen+1:sweeplen+gaplen+29*MLSlen,:,:,:,:,:);
gapmargin = round(MLSlen*0.05);
MLSgap = IN.audio(MLSgapstart+gapmargin:MLSgapstart+MLSlen-gapmargin,:,:,:,:,:);
NoisebeforeMLS = IN.audio(sweeplen+1+gapmargin:sweeplen+gaplen-gapmargin,:,:,:,:,:);
[SigPow2, NoiseDistPow,NoisebeforeMLSPow,SNR2,SINAD] = deal(zeros(floor(winlen/2),chans,dim5,dim6));  
for ch = 1:chans
    for d5 = 1:dim5
        for d6 = 1:dim6
            [~,f,~,P1] = spectrogram(MLSnoise1(:,ch,1,1,d5,d6),wf,NOVERLAP,[],fs);
            [~,~,~,P2] = spectrogram(MLSnoise2(:,ch,1,1,d5,d6),wf,NOVERLAP,[],fs);
            [~,~,~,P3] = spectrogram(MLSgap(:,ch,1,1,d5,d6),wf,NOVERLAP,[],fs);
            [~,~,~,P4] = spectrogram(NoisebeforeMLS(:,ch,1,1,d5,d6),wf,NOVERLAP,[],fs);
            NoiseDistPow(:,ch,d5,d6) = mean(P3(1:floor(winlen/2),:),2);
            NoisebeforeMLSPow(:,ch,d5,d6) = mean(P4(1:floor(winlen/2),:),2);
            SigPow2(:,ch,d5,d6) = mean([P1(1:floor(winlen/2),:),...
                P2(1:floor(winlen/2),:)],2);
            SNR2(:,ch,d5,d6) = SigPow2(:,ch,d5,d6)./NoisebeforeMLSPow(:,ch,d5,d6); % although this looks inefficient, it is done here to avoid smoothing artefacts
            SINAD(:,ch,d5,d6) = SigPow2(:,ch,d5,d6)./NoiseDistPow(:,ch,d5,d6);
            if octsmooth > 0
                NoisebeforeMLSPow(:,ch,d5,d6) = octavesmoothing(NoisebeforeMLSPow(:,ch,d5,d6),octsmooth, fs);
                NoiseDistPow(:,ch,d5,d6) = octavesmoothing(NoiseDistPow(:,ch,d5,d6),octsmooth, fs);
                SigPow2(:,ch,d5,d6) = octavesmoothing(SigPow2(:,ch,d5,d6),octsmooth, fs);
                SNR2(:,ch,d5,d6) = octavesmoothing(SNR2(:,ch,d5,d6),octsmooth, fs);
                SINAD(:,ch,d5,d6) = octavesmoothing(SINAD(:,ch,d5,d6),octsmooth, fs);
            end
        end
    end
end
clear MLSnoise1 MLSnoise2 MLSgap NoisebeforeMLS P1 P2 P3 P4
f=f(1:floor(winlen/2));
if octsmooth > 0
    lowlimit = 128/(winlen/fs); % avoid very low freq hump error
    NoisebeforeMLSPow = NoisebeforeMLSPow(f>lowlimit,:,:,:,:,:);
    NoisebeforeMLSPow(NoisebeforeMLSPow<0)=0;
    NoiseDistPow = NoiseDistPow(f>lowlimit,:,:,:,:,:);
    NoiseDistPow(NoiseDistPow<0)=0;
    SigPow2 = SigPow2(f>lowlimit,:,:,:,:,:);
    SigPow2(SigPow2<0)=0;
    SNR2 = SNR2(f>lowlimit,:,:,:,:,:);
    SNR2(SNR2<0)=0;
    SINAD = SINAD(f>lowlimit,:,:,:,:,:);
    SINAD(SINAD<0)=0;
    f = f(f>lowlimit);
end


% Generate figure(s) for SNR analysis
for d6 = 1:dim6
    figure('Name','Signal, Noise, and SNR');
    for ch = 1:chans
        for d5 = 1:dim5
            labelstring = 'hello';
            
            subplot(2,1,1) % plot of Signal and Noise spectra
            colr = permute(linecolor(ch,1,d5,:),[1,4,2,3]);
            semilogx(f,10*log10(NoisebeforeMLSPow(:,ch,d5,d6)),...
                'color',colr,...
                'DisplayName',labelstring);
            hold on
            
            colr = permute(linecolor(ch,2,d5,:),[1,4,2,3]);
            semilogx(f,10*log10(NoiseDistPow(:,ch,d5,d6)),...
                'color',colr,...
                'DisplayName',labelstring);
            
            colr = permute(linecolor(ch,3,d5,:),[1,4,2,3]);
            semilogx(f,10*log10(SigPow2(:,ch,d5,d6)),...
                'color',colr,...
                'DisplayName',labelstring);
            
            
            colr = permute(linecolor(ch,2,d5,:),[1,4,2,3]);
            subplot(2,1,2) % plot of SNR
            semilogx(f,10*log10(SNR2(:,ch,d5,d6)),...
                'color',colr,...
                'DisplayName',labelstring);
            hold on
            colr = permute(linecolor(ch,4,d5,:),[1,4,2,3]);
                semilogx(f,10*log10(SINAD(:,ch,d5,d6)),...
                'color',colr,...
                'DisplayName',labelstring);
        end
    end
    subplot(2,1,1)
    title('Signal, Noise and Distorion+Noise')
    xlabel('Frequency [Hz]')
    ylabel('Level [dB]')
    xlim([20,20000])
    
    subplot(2,1,2)
    title('SNR and SINAD')
    xlabel('Frequency [Hz]')
    ylabel('Level [dB]')
    xlim([20,20000])
end


% ANALYSE IR FROM MLS


% ANALYSE IR FROM SWEEP, INCLUDING HARMONIC DISTORTION




OUT = [];

%**************************************************************************
% Copyright (c) 2015, Densil Cabrera
% All rights reserved.
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are
% met:
%
%  * Redistributions of source code must retain the above copyright notice,
%    this list of conditions and the following disclaimer.
%  * Redistributions in binary form must reproduce the above copyright
%    notice, this list of conditions and the following disclaimer in the
%    documentation and/or other materials provided with the distribution.
%  * Neither the name of the The University of Sydney nor the names of its contributors
%    may be used to endorse or promote products derived from this software
%    without specific prior written permission.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
% "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
% TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
% PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
% OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
% EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
% PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
% PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
% LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
% NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
% SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%**************************************************************************